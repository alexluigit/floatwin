#!/usr/bin/env bash
__add_float_rule() {
  case $WM in
    bspwm) bspc rule -a $CLASS:$INSTANCE -o state=floating;;
    awesome)
      [[ -n $CLASS ]] && local c="class={\"$CLASS\"},"
      [[ -n $INSTANCE ]] && local i="instance={\"$INSTANCE\"},"
      [[ -n $NAME ]] && local n="name={\"$NAME\"},"
      local rule_aw="require('ruled').client.append_rule{id='fw',rule_any={$c$i$n},properties={floating=true}}"
      awesome-client "$rule_aw";;
  esac
}
__remove_float_rule() { [[ $WM == "awesome" ]] && awesome-client "require('ruled').client.remove_rule('fw')"; }
__run_hook() { [[ -n "$1" ]] && eval "$1"; }
__parse_dimension() {
  local _w=$(awk -F+ '{print $1}' <<< $GEO | awk -Fx '{print $1}' | tee $APP_CACHE)
  local _h=$(awk -F+ '{print $1}' <<< $GEO | awk -Fx '{print $2}' | tee -a $APP_CACHE)
  local _x=$(awk -F+ '{print $2}' <<< $GEO | tee -a $APP_CACHE)
  local _y=$(awk -F+ '{print $3}' <<< $GEO | tee -a $APP_CACHE)
  "$TILING" && echo "tiling" >> $APP_CACHE || echo "floating" >> $APP_CACHE
}
__save_floating() {
  local state=floating
  case $WM in
    awesome) [[ -n $(awesome-client "return client.focus.floating" | grep false) ]] && state=tiling;;
    bspwm) [[ -n $(bspc query -T -n | grep '"state":"floating"') ]] || state=tiling;;
  esac
  sed -i "5s/.*/$state/" $APP_CACHE
}

_win_visible() { [[ $(xwininfo -id "$WID" 2> /dev/null | gawk '/Map State/ {print $3}') == IsViewable ]]; }
_win_is_current() { [[ $(xdo id) == $WID ]]; }
_wid_expired() {
  wid_name=$(xprop -id $WID 2>/dev/null | grep "^WM_NAME(.*)" 2>/dev/null | awk '{print $3}' | tr -d ',"')
  [[ -z $wid_name ]] && return 0
  [[ "$wid_name" = "$NAME" ]] && return 1
  wid_class=$(xprop -id $WID 2>/dev/null | grep "WM_CLASS(STRING)" 2>/dev/null | awk '{print $NF}' | tr -d ',"')
  wid_instance=$(xprop -id $WID 2>/dev/null | grep "WM_CLASS(STRING)" 2>/dev/null | awk '{print $3}' | tr -d ',"')
  [[ "$wid_class" = "$CLASS" ]] && [[ -z $INSTANCE ]] && return 1
  [[ "$wid_instance" = "$INSTANCE" ]] && return 1
}
_pop_window () { xdotool windowactivate $WID; }
_hide_window () { __save_floating; xdotool windowunmap $WID; }
_show_window() {
  local state=$(sed -n 5p $APP_CACHE)
  __run_hook $BEFORE_MAP
  xdotool set_desktop_for_window "${1:-$WID}" "$(xdotool get_desktop)"
  if [[ $state == "tiling" ]]; then
    xdotool windowmap ${1:-$WID}
  else
    w=$(sed -n 1p $APP_CACHE) h=$(sed -n 2p $APP_CACHE)
    x=$(sed -n 3p $APP_CACHE) y=$(sed -n 4p $APP_CACHE)
    [[ $state == "floating" ]] && __add_float_rule
    xdotool windowmap ${1:-$WID} windowmove ${1:-$WID} $x $y windowsize ${1:-$WID} $w $h
  fi
  __run_hook $AFTERMAP
  __remove_float_rule
}
_create_window() {
  __run_hook $BEFORE_CREATE
  __parse_dimension
  t_cmd=(alacritty --class $INSTANCE,$CLASS)
  [[ "$APP" == "dropterm" ]] || t_cmd+=("-e ${CMD[@]}")
  t_cmd=(`echo ${t_cmd[@]} | sed 's/\"/\\\"/g'`)
  g_cmd=(`echo ${CMD[@]} | sed 's/\"/\\\"/g'`)
  _intercept &
  $TILING || __add_float_rule
  $TERMINAL && eval "${t_cmd[@]} &" || eval "${g_cmd[@]} &"
  __run_hook $AFTER_CREATE
}
_intercept() {
  local wid timeout=1000 exceeded=false
  local search=(xdo id -d)
  [[ -n $CLASS ]] && search+=("-N $CLASS")
  [[ -n $INSTANCE ]] && search+=("-n $INSTANCE")
  [[ -n $NAME ]] && search+=("-a $NAME")
  counter=0
  while true; do
    new_wid=$(eval ${search[@]})
    [[ -n $new_wid ]] && break
    [[ $counter -gt $timeout ]] && { exceeded=true; break; }
    sleep .01; counter=$((counter + 1))
  done
  $exceeded && _log "Wait for $CLASS:${INTERCEPT_FROM:-$INSTANCE} timeout." && exit 1;
  wid=$new_wid; [[ -n $INTERCEPT_FROM ]] && xdotool set_window --classname $INSTANCE $wid
  _show_window $wid
  echo $wid >> $APP_CACHE
}
_log() { echo "$@" >> $FLOATWIN/log; }
_meta() {
  local id=$(xprop -root -notype _NET_SUPPORTING_WM_CHECK); id=${id##* }
  wm=$(xprop -notype -id "$id" _NET_WM_NAME | head -n 1); wm=${wm##* }; wm=${wm//\"/}
  echo $wm > $FLOATWIN/000META
}

toggle_or_create() {
  if _wid_expired; then _create_window
  elif _win_visible; then
    _win_is_current && _hide_window || _pop_window
  else
    _show_window
  fi
}

FLOATWIN="$XDG_CACHE_HOME/floatwin"
TERMINAL=false
GEO=1920x1080+50+50
RESET=false
INTERCEPT=false
TILING=false

[[ -d "$FLOATWIN" ]] || mkdir -p $FLOATWIN
[[ -f "$FLOATWIN/000META" ]] || _meta

while getopts "a:A:b:B:c:f:g:i:I:n:tTr" opt; do
  case $opt in
    a) AFTER_MAP=$OPTARG;;
    b) BEFORE_MAP=$OPTARG;;
    A) AFTER_CREATE=$OPTARG;;
    B) BEFORE_CREATE=$OPTARG;;
    c) CLASS=${OPTARG%:*}; INSTANCE=${OPTARG#*:};;
    g) GEO=$OPTARG;;
    f) INTERCEPT_FROM=$OPTARG;;
    i) INDEX=$OPTARG;;
    I) INTERCEPT=true; CLASS=${OPTARG%:*}; INSTANCE=${OPTARG#*:};;
    n) NAME=$OPTARG;;
    T) TILING=true;;
    t) TERMINAL=true;;
    r) RESET=true;;
  esac
done
shift $((OPTIND -1))

WM=$(cat "$FLOATWIN/000META")
CMD="${@}"; [[ -z $CMD ]] && CMD="echo"
APP=${1:-dropterm}
$RESET && { rm -rf $FLOATWIN; echo "cache cleared."; exit 0; }
$TERMINAL && { CLASS=${CLASS:-$APP}; INSTANCE=${INSTANCE:-$CLASS}; }
[[ -n $INDEX ]] && INSTANCE=$INSTANCE.$INDEX
APP_CACHE=$FLOATWIN/$APP.${INDEX:-0}
$INTERCEPT && { _intercept; exit 0; }
WID=$(tail -n 1 "$APP_CACHE" 2>/dev/null)

toggle_or_create
